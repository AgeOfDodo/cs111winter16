

Q 1.1 why does it take this many threads or iterations?
if number of threads/iterations is small, “its not possiblet to say the result is wrong” 
no conflicts of calling add() if few enough threads? so smaller iterations rarely fail?

Q 1.2
if # iterations small, then overhead of creating threads, 

Q 2.1
time per operation drops as the number of iterations increases becasue the overhead of creating thread are fairly distributed to each operation in our calulation.

To demostrate conflicts between inserts(--yield=i), we have 16 threads and 150 iterations. To check that the conflicts actually happen between inserts, we print out a "before" line before each call to insert() and an "after" line after. If there are several "before" lines printed out right before seg fault, then we know that the conflict happens between inserts.

Using the same mothod, we can demostrate conflicts between deletes(yield=d), inserts and lookups (yield=is), and delete and lookup(yield=ds). 	

When using --sync=m or --sync=s, we don't have seg fault.
See graph.pdf for graphs. 

Q 2.2

Compare the two parts
For --lists implementation, see code in sltest.c, especially in hash(), threadFunc(), 

